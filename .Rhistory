AIC_adj <- function(mod, p){
# Number of observations
n.N   <- nrow(mod$model)
# Residuals vector
u.hat <- residuals(mod)
# Variance estimation
s.sq  <- log( (sum(u.hat^2)/(n.N)))
# Number of parameters (incl. constant) + one additional for variance estimation
p     <-  p
# Note: minus sign cancels in log likelihood
aic <- 2*p  +  n.N * (  log(2*pi) + s.sq  + 1 )
return(aic)
}
# 3. Plots
{
# 3.1  define plot function
plt_metric <- function (var, year, title, caption, legend, breaks) {
var <- enquo(var)
ggplot() +
geom_polygon(data = locs_sp[locs_sp$year == year,], aes(x=long, y=lat, group=group, fill=!!var), colour='black', size=0.5, alpha=0.9) +
coord_sf() +
scale_fill_viridis(trans = "log1p",
breaks = breaks, labels = breaks
) +
labs(
caption = caption,
title = title,
fill = legend
) +
theme_void() +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
plot.background = element_blank(),
plot.title = element_text(color="#000000", face="bold", size=16, hjust=0),
plot.caption = element_text(color="#000000", face="bold", size=10, hjust=1),
plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
strip.text.x = element_text(color="#505050", face="bold", size=12, hjust=0.5),
legend.title = element_text(color="#505050", face="bold", size=12, hjust=1),
legend.text = element_text(color="#505050", size=10, angle = 0),
legend.position = 'bottom'
) +
guides(
fill = guide_colourbar(
ticks.colour = "white",
ticks.linewidth = 1.2,
barwidth=15,
label.position="bottom"))
}
# 3.2. define plot function to compare 2 years
plt_compare <- function (var, year1, year2, title, caption, legend, breaks) {
var <- enquo(var)
ggplot() +
geom_polygon(data = locs_sp[locs_sp$year %in% c(year1, year2),], aes(x=long, y=lat, group=group, fill=!!var), colour='black', size=0.5, alpha=0.9) +
coord_sf() +
facet_wrap(~year) +
scale_fill_viridis(trans = "log1p",
breaks = breaks, labels = breaks
) +
labs(
caption = caption,
title = title,
fill = legend
) +
theme_void() +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
plot.background = element_blank(),
plot.title = element_text(color="#000000", face="bold", size=16, hjust=0),
plot.caption = element_text(color="#000000", face="bold", size=10, hjust=1),
plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
strip.text.x = element_text(color="#505050", face="bold", size=12, hjust=0.5),
legend.title = element_text(color="#505050", face="bold", size=12, hjust=1),
legend.text = element_text(color="#505050", size=10, angle = 0),
legend.position = 'bottom'
) +
guides(
fill = guide_colourbar(
ticks.colour = "white",
ticks.linewidth = 1.2,
barwidth=15,
label.position="bottom"))
}
# 3.3. plot bu/bur/br
plt_bu_bur_bu <- locs_sp %>%
mutate(
b = case_when(
bu == '1' ~ 'urban',
bur == '1' ~ 'urban-rural',
T ~ 'rural'
)) %>%
filter(
year == 2018
) %>%
ggplot() +
geom_polygon(aes(x=long, y=lat, group=group, fill=b), colour='black', size=0.5, alpha=0.9) +
coord_sf() +
scale_fill_viridis(discrete=T) +
labs(
caption = 'Data Source: Polish Statistical Office',
title = 'a) type of borough',
fill = 'type'
) +
theme_void() +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
plot.background = element_blank(),
plot.title = element_text(color="#000000", face="bold", size=16, hjust=0),
plot.caption = element_text(color="#000000", face="bold", size=10, hjust=1),
plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
strip.text.x = element_text(color="#505050", face="bold", size=12, hjust=0.5),
legend.title = element_text(color="#505050", face="bold", size=12, hjust=1),
legend.text = element_text(color="#505050", size=10, angle = 0),
legend.position = 'bottom'
)
# 3.4. plots for time-invariant variables
plt_dist <- plt_metric(dist, 2018, 'c) distance', 'Data Source: Google Maps', 'km', c(10, 12, 15, 20, 25, 30, 40, 50))
plt_train <- locs_sp %>%
mutate(
train = case_when(
train == '1' ~ 'presence of suburban train station',
T ~ 'lack of suburban train station'
)) %>%
filter(
year == 2018
) %>%
ggplot() +
geom_polygon(aes(x=long, y=lat, group=group, fill=train), colour='black', size=0.5, alpha=0.9) +
coord_sf() +
scale_fill_viridis(discrete=T) +
labs(
caption = 'Data Source: Google Maps',
title = 'b) suburban train station',
fill = ''
) +
theme_void() +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
plot.background = element_blank(),
plot.title = element_text(color="#000000", face="bold", size=16, hjust=0),
plot.caption = element_text(color="#000000", face="bold", size=10, hjust=1),
plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
strip.text.x = element_text(color="#505050", face="bold", size=12, hjust=0.5),
legend.title = element_text(color="#505050", face="bold", size=12, hjust=1),
legend.text = element_text(color="#505050", size=10, angle = 0),
legend.position = 'bottom'
)
# 3.5. combined plot for all variables
plt_check_in <- plt_compare(check_in, 2008, 2018, 'd) migrants', 'Data Source: Polish Statistical Office', '# of migrants', c(1, 2, 5, 10, 25, 50, 100, 250, 750))
plt_income <- plt_compare(income, 2008, 2018, 'e) income per capita', 'Data Source: own calculation based on data from Polish Statistical Office', 'ratio', c(0.3, 0.5, 0.75, 1, 1.5, 2, 2.5, 3))
plt_kinder <- plt_compare(kinder, 2008, 2018, 'f) number of kindergartens', 'Data Source: Polish Statistical Office', '# of kindergartens', c(1, 2, 5, 10, 25, 50, 75, 100))
plt_unempl <- plt_compare(unempl, 2008, 2018, 'g) unemployment rate', 'Data Source: Polish Statistical Office', 'ratio', seq(0, 0.1, 0.01))
plt_pop_density <- plt_compare(pop_density, 2008, 2018, 'h) population density', 'Data Source: Polish Statistical Office', '', c(0.5, 1, 2, 3, 5, 7, 10, 15, 20, 30)) +
labs(fill = expression(bold(paste('# of people / ', km^2))))
plt_greenery <- plt_compare(greenery, 2008, 2018, 'i) area of green amenities (parks etc.)', 'Data Source: Polish Statistical Office', 'area in ha', c(2, 5, 10, 25, 50, 100, 250))
plt_average_b_waw <- plt_compare(average_b_waw, 2008, 2018, 'j) relative price of housing', 'Data Source: Polish Statistical Office & suburban county officies', 'ratio', c(0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6))
plt_bu_bur_bu
png('img/maps_combined.png', width = 3508, height = 2*2480, res=300)
plot_grid(plt_bu_bur_bu, plt_dist, plt_train, plt_check_in, plt_income, plt_kinder, plt_unempl, plt_pop_density, plt_greenery, plt_average_b_waw, ncol = 2, greedy=F)
dev.off()
}
# 0. initial set-up
{
# 0.1. clear env
rm(list = ls())
# 0.2. load packages
requiredPackages <- c('tidyverse', 'haven', 'readxl', 'utf8', 'rjson', 'osmdata', 'sf', 'sp', 'broom', 'viridis', 'cowplot', 'reshape2', 'spatialreg', 'spdep', 'splm', 'Metrics', 'stargazer')
for (i in requiredPackages) {
if (!require(i,character.only = T)) {
install.packages(i, character.only = T)
}
}
# 0.3. define custom functions
r2 <- function (actual, res) {
rss <- sum(res^2)
tss <- sum((actual - mean(actual)) ^ 2)
r2 <- 1 - rss/tss
return (r2)
}
r2_adj <- function (actual, res, p = 29) {
n <- 759
r2_adj <- 1 - ((1 - r2(actual, res)) * (n - 1) / (n - p - 1))
return (r2_adj)
}
rmse <- function (res) {
return (sqrt(sum(res^2)/759))
}
# https://stackoverflow.com/questions/46186527/how-to-calculate-bic-and-aic-for-a-gmm-model-in-r-using-plm
AIC_adj <- function(mod, p){
# Number of observations
n.N   <- nrow(mod$model)
# Residuals vector
u.hat <- residuals(mod)
# Variance estimation
s.sq  <- log( (sum(u.hat^2)/(n.N)))
# Number of parameters (incl. constant) + one additional for variance estimation
p     <-  p
# Note: minus sign cancels in log likelihood
aic <- 2*p  +  n.N * (  log(2*pi) + s.sq  + 1 )
return(aic)
}
}
# 1. since our code was deleted, we will be using the files that were saved during development, but the code is unavailable
{
# 1.1. file with dependent and independent variables in years 2008-2019 (only check_in is available for 2019)
data <- read.csv('data/data.csv', sep = ',')
# 1.2. file with OSM IDs for all borough (was required for downloading the data from OSM and will be used to sort the observations)
boroughs_osm <- read.csv('data/boroughs_osm.csv', sep = ',')
# 1.3. file with borough polygons (downloaded from OSM using osmdata package and transformed to correct CRS)
locs <- readRDS('data/locs.RDS')
# 1.4. file with borough polygons joined with information from data file (locs + data)
locs_sp <- readRDS('data/locs_sp.RDS')
}
# 2. let's prepare data from modeling
{
# 2.1. filter out 2019 since it only contains target variable
data_model <- data %>%
filter(year != 2019)
# 2.2. some variables do not change over time, and thus we should find only spatial lags for them
variables_constant <- c('bu', 'bur', 'br', 'dist', 'train')
# 2.3. now let's select the variables that do change over time
variables_temporal <- c('check_in', 'income', 'kinder', 'unempl', 'pop_density', 'greenery', 'average_b_waw')
# 2.4. convert binary variables to categorical
data_model <- data_model %>%
mutate_at(c('bu', 'bur', 'br', 'train'), as.factor)
# 2.4. add osm_id and select columns for modeling
data_model <- data_model %>%
merge(boroughs_osm, by = 'borough') %>%
dplyr::select(osm_id, year, variables_constant[variables_constant!='br'], all_of(variables_temporal)) %>%
arrange(osm_id, year)
# 2.5. create spatial weights matrix
locs$osm_multipolygons <- arrange(locs$osm_multipolygons, rownames(locs$osm_multipolygons))
cont.nb <- poly2nb(as(locs$osm_multipolygons, 'Spatial'))
cont.listw <- nb2listw(cont.nb, style="W")
}
# 3. Plots
{
# 3.1  define plot function
plt_metric <- function (var, year, title, caption, legend, breaks) {
var <- enquo(var)
ggplot() +
geom_polygon(data = locs_sp[locs_sp$year == year,], aes(x=long, y=lat, group=group, fill=!!var), colour='black', size=0.5, alpha=0.9) +
coord_sf() +
scale_fill_viridis(trans = "log1p",
breaks = breaks, labels = breaks
) +
labs(
caption = caption,
title = title,
fill = legend
) +
theme_void() +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
plot.background = element_blank(),
plot.title = element_text(color="#000000", face="bold", size=16, hjust=0),
plot.caption = element_text(color="#000000", face="bold", size=10, hjust=1),
plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
strip.text.x = element_text(color="#505050", face="bold", size=12, hjust=0.5),
legend.title = element_text(color="#505050", face="bold", size=12, hjust=1),
legend.text = element_text(color="#505050", size=10, angle = 0),
legend.position = 'bottom'
) +
guides(
fill = guide_colourbar(
ticks.colour = "white",
ticks.linewidth = 1.2,
barwidth=15,
label.position="bottom"))
}
# 3.2. define plot function to compare 2 years
plt_compare <- function (var, year1, year2, title, caption, legend, breaks) {
var <- enquo(var)
ggplot() +
geom_polygon(data = locs_sp[locs_sp$year %in% c(year1, year2),], aes(x=long, y=lat, group=group, fill=!!var), colour='black', size=0.5, alpha=0.9) +
coord_sf() +
facet_wrap(~year) +
scale_fill_viridis(trans = "log1p",
breaks = breaks, labels = breaks
) +
labs(
caption = caption,
title = title,
fill = legend
) +
theme_void() +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
plot.background = element_blank(),
plot.title = element_text(color="#000000", face="bold", size=16, hjust=0),
plot.caption = element_text(color="#000000", face="bold", size=10, hjust=1),
plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
strip.text.x = element_text(color="#505050", face="bold", size=12, hjust=0.5),
legend.title = element_text(color="#505050", face="bold", size=12, hjust=1),
legend.text = element_text(color="#505050", size=10, angle = 0),
legend.position = 'bottom'
) +
guides(
fill = guide_colourbar(
ticks.colour = "white",
ticks.linewidth = 1.2,
barwidth=15,
label.position="bottom"))
}
# 3.3. plot bu/bur/br
plt_bu_bur_bu <- locs_sp %>%
mutate(
b = case_when(
bu == '1' ~ 'urban',
bur == '1' ~ 'urban-rural',
T ~ 'rural'
)) %>%
filter(
year == 2018
) %>%
ggplot() +
geom_polygon(aes(x=long, y=lat, group=group, fill=b), colour='black', size=0.5, alpha=0.9) +
coord_sf() +
scale_fill_viridis(discrete=T) +
labs(
caption = 'Data Source: Polish Statistical Office',
title = 'a) type of borough',
fill = 'type'
) +
theme_void() +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
plot.background = element_blank(),
plot.title = element_text(color="#000000", face="bold", size=16, hjust=0),
plot.caption = element_text(color="#000000", face="bold", size=10, hjust=1),
plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
strip.text.x = element_text(color="#505050", face="bold", size=12, hjust=0.5),
legend.title = element_text(color="#505050", face="bold", size=12, hjust=1),
legend.text = element_text(color="#505050", size=10, angle = 0),
legend.position = 'bottom'
)
# 3.4. plots for time-invariant variables
plt_dist <- plt_metric(dist, 2018, 'c) distance', 'Data Source: Google Maps', 'km', c(10, 12, 15, 20, 25, 30, 40, 50))
plt_train <- locs_sp %>%
mutate(
train = case_when(
train == '1' ~ 'presence of suburban train station',
T ~ 'lack of suburban train station'
)) %>%
filter(
year == 2018
) %>%
ggplot() +
geom_polygon(aes(x=long, y=lat, group=group, fill=train), colour='black', size=0.5, alpha=0.9) +
coord_sf() +
scale_fill_viridis(discrete=T) +
labs(
caption = 'Data Source: Google Maps',
title = 'b) suburban train station',
fill = ''
) +
theme_void() +
theme(
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_blank(),
plot.background = element_blank(),
plot.title = element_text(color="#000000", face="bold", size=16, hjust=0),
plot.caption = element_text(color="#000000", face="bold", size=10, hjust=1),
plot.margin = unit(c(0.5,0.5,0.5,0.5), "cm"),
strip.text.x = element_text(color="#505050", face="bold", size=12, hjust=0.5),
legend.title = element_text(color="#505050", face="bold", size=12, hjust=1),
legend.text = element_text(color="#505050", size=10, angle = 0),
legend.position = 'bottom'
)
# 3.5. combined plot for all variables
plt_check_in <- plt_compare(check_in, 2008, 2018, 'd) migrants', 'Data Source: Polish Statistical Office', '# of migrants', c(1, 2, 5, 10, 25, 50, 100, 250, 750))
plt_income <- plt_compare(income, 2008, 2018, 'e) income per capita', 'Data Source: own calculation based on data from Polish Statistical Office', 'ratio', c(0.3, 0.5, 0.75, 1, 1.5, 2, 2.5, 3))
plt_kinder <- plt_compare(kinder, 2008, 2018, 'f) number of kindergartens', 'Data Source: Polish Statistical Office', '# of kindergartens', c(1, 2, 5, 10, 25, 50, 75, 100))
plt_unempl <- plt_compare(unempl, 2008, 2018, 'g) unemployment rate', 'Data Source: Polish Statistical Office', 'ratio', seq(0, 0.1, 0.01))
plt_pop_density <- plt_compare(pop_density, 2008, 2018, 'h) population density', 'Data Source: Polish Statistical Office', '', c(0.5, 1, 2, 3, 5, 7, 10, 15, 20, 30)) +
labs(fill = expression(bold(paste('# of people / ', km^2))))
plt_greenery <- plt_compare(greenery, 2008, 2018, 'i) area of green amenities (parks etc.)', 'Data Source: Polish Statistical Office', 'area in ha', c(2, 5, 10, 25, 50, 100, 250))
plt_average_b_waw <- plt_compare(average_b_waw, 2008, 2018, 'j) relative price of housing', 'Data Source: Polish Statistical Office & suburban county officies', 'ratio', c(0.01, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6))
plt_bu_bur_bu
png('img/maps_combined.png', width = 3508, height = 2*2480, res=300)
plot_grid(plt_bu_bur_bu, plt_dist, plt_train, plt_check_in, plt_income, plt_kinder, plt_unempl, plt_pop_density, plt_greenery, plt_average_b_waw, ncol = 2, greedy=F)
dev.off()
}
form_all <- check_in ~ bu + bur + dist + train + income + kinder + unempl + pop_density + greenery + average_b_waw
form_time <- check_in ~ income + kinder + unempl + pop_density + greenery + average_b_waw
bsjktest(form_all, data=data_model, listw=cont.listw, test="C.1") # H0 rejected -> 'spatial dependence in error terms, sub RE and serial corr.'
bsjktest(form_time, data=data_model, listw=cont.listw, test="J") # H0 rejected -> 'random effects or serial corr. spatial dependence in error terms'
sphtest(form_time, data=data_model, listw=cont.listw, spatial.model="error", method="ML", errors = 'BSK') # H0 rejected -> Fixed Effects
sphtest(form_time, data=data_model, listw=cont.listw, spatial.model="lag", method="ML", errors = 'BSK') # H0 rejected -> Fixed Effects
sphtest(form_time, data=data_model, listw=cont.listw, spatial.model="sarar", method="ML", errors = 'BSK') # H0 rejected -> Fixed Effects
# model with FE for time, Baltagi errors and y lags
model_spml_1 <-spml(form_all, data=data_model, listw=cont.listw, model="within", spatial.error="b", lag=T, effect="time")
summary(model_spml_1)
{
model_stats <- data.frame(
model_name = rep('', 9),
params = c(10, 10 + 2 + 11, 10 + 1 + 11, 6 + 2 + 69, 6 + 1 + 69, 6 + 2 + 11 + 69, 6 + 1 + 11 + 69, 10 + 2, 10 + 1),
formula = c(rep('form_all', 3), rep('form_time', 4), rep('form_all', 2)),
param_model = c(NA, rep("within", 6), rep('pooling', 2)),
param_spatial.error = c(NA, rep("b", 8)),
param_lag = c(NA, rep(c(T, F), 4)),
param_effect = c(NA, rep('time', 2), rep('individual', 2), rep('twoway', 2), rep(NA, 2)),
rmse = rep(0, 9),
r2 = rep(0, 9),
r2_adj = rep(0, 9),
aic_adj = rep(0, 9)
)
i <- 1
for (model in c('model_ols', paste0('model_spml_', seq(1,8)))) {
# p <- length(get(model)$coefficients) + length(get(model)$vcov.arcoef) + length(get(model)$vcov.errcomp) +
#  tryCatch(nrow(effects(get(model))$INTTable), error=function(err) 0) + tryCatch(nrow(effects(get(model))$SETable), error=function(err) 0) + tryCatch(nrow(effects(get(model))$TETable), error=function(err) 0)
model_stats[i,'model_name'] <- model
model_stats[i,'rmse'] <- rmse(get(model)$residuals)
model_stats[i,'r2'] <- r2(data_model$check_in, get(model)$residuals)
model_stats[i,'r2_adj'] <- r2_adj(data_model$check_in, get(model)$residuals, model_stats[i,'params'])
model_stats[i,'aic_adj'] <- AIC_adj(get(model), model_stats[i,'params'])
i <- i+1
}
}
# ols
model_ols<-lm(form_all, data=data_model)
summary(model_ols)
# model with FE for time, Baltagi errors and y lags
model_spml_1 <-spml(form_all, data=data_model, listw=cont.listw, model="within", spatial.error="b", lag=T, effect="time")
summary(model_spml_1)
# model with FE for time and Baltagi errors
model_spml_2<-spml(form_all, data=data_model, listw=cont.listw, model="within", spatial.error="b", lag=F, effect="time")
summary(model_spml_2)
# model with FE for boroughs, Baltagi errors and y lags
model_spml_3<-spml(form_time, data=data_model, listw=cont.listw, model="within", spatial.error="b", lag=T, effect="individual")
summary(model_spml_3)
# model with FE for boroughs, Baltagi errors and y lags
model_spml_4<-spml(form_time, data=data_model, listw=cont.listw, model="within", spatial.error="b", lag=F, effect="individual")
summary(model_spml_4)
# model with FE for time & boroughs, Baltagi errors and y lags
model_spml_5<-spml(form_time, data=data_model, listw=cont.listw, model="within", spatial.error="b", lag=T, effect="twoway")
summary(model_spml_5)
# model with FE for time & boroughs, Baltagi errors and y lags
model_spml_6<-spml(form_time, data=data_model, listw=cont.listw, model="within", spatial.error="b", lag=F, effect="twoway")
summary(model_spml_6)
# model without FE, Baltagi errors and y lags
model_spml_7<-spml(form_all, data=data_model, listw=cont.listw, model="pooling", spatial.error="b", lag=T)
summary(model_spml_7)
# model without FE, Baltagi errors and y lags
model_spml_8<-spml(form_all, data=data_model, listw=cont.listw, model="pooling", spatial.error="b", lag=F)
summary(model_spml_8)
{
model_stats <- data.frame(
model_name = rep('', 9),
params = c(10, 10 + 2 + 11, 10 + 1 + 11, 6 + 2 + 69, 6 + 1 + 69, 6 + 2 + 11 + 69, 6 + 1 + 11 + 69, 10 + 2, 10 + 1),
formula = c(rep('form_all', 3), rep('form_time', 4), rep('form_all', 2)),
param_model = c(NA, rep("within", 6), rep('pooling', 2)),
param_spatial.error = c(NA, rep("b", 8)),
param_lag = c(NA, rep(c(T, F), 4)),
param_effect = c(NA, rep('time', 2), rep('individual', 2), rep('twoway', 2), rep(NA, 2)),
rmse = rep(0, 9),
r2 = rep(0, 9),
r2_adj = rep(0, 9),
aic_adj = rep(0, 9)
)
i <- 1
for (model in c('model_ols', paste0('model_spml_', seq(1,8)))) {
# p <- length(get(model)$coefficients) + length(get(model)$vcov.arcoef) + length(get(model)$vcov.errcomp) +
#  tryCatch(nrow(effects(get(model))$INTTable), error=function(err) 0) + tryCatch(nrow(effects(get(model))$SETable), error=function(err) 0) + tryCatch(nrow(effects(get(model))$TETable), error=function(err) 0)
model_stats[i,'model_name'] <- model
model_stats[i,'rmse'] <- rmse(get(model)$residuals)
model_stats[i,'r2'] <- r2(data_model$check_in, get(model)$residuals)
model_stats[i,'r2_adj'] <- r2_adj(data_model$check_in, get(model)$residuals, model_stats[i,'params'])
model_stats[i,'aic_adj'] <- AIC_adj(get(model), model_stats[i,'params'])
i <- i+1
}
}
View(model_stats)
impacts(model_spml_7, listw = cont.listw, time = 11)
View(model_stats)
impacts(model_spml_5, listw = cont.listw, time = 11)
summary(model_spml_5)
summary(model_spml_7)
summary(model_spml_1)
summary(model_spml_3)
impacts(model_spml_5, listw = cont.listw, time = 11)
summary(model_spml_5)
summary(model_spml_6)
summary(model_spml_4)
summary(model_spml_2)
effects(model_spml_5)
summary(model_spml_4)
View(model_stats)
summary(model_spml_4)
summary(model_spml_3)
summary(model_spml_6)
summary(model_spml_6)
summary(model_ols)
summary(model_spml_7)
summary(model_spml_8)
impacts(model_spml_5, listw = cont.listw, time = 11)
effects(model_spml_5)
summary(model_spml_5)
